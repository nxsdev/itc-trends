import { pgTable, foreignKey, unique, uuid, timestamp, integer, date, index, varchar, text, boolean, time, numeric } from "drizzle-orm/pg-core"
  import { sql } from "drizzle-orm"



export const insuredCounts = pgTable("insured_counts", {
	id: uuid("id").defaultRandom().primaryKey().notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	companyId: uuid("company_id").notNull().references(() => companies.id),
	insuredCount: integer("insured_count").notNull(),
	countDate: date("count_date").notNull(),
},
(table) => {
	return {
		insuredCountsCompanyIdCountDateUnique: unique("insured_counts_company_id_count_date_unique").on(table.companyId, table.countDate),
	}
});

export const companies = pgTable("companies", {
	id: uuid("id").defaultRandom().primaryKey().notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	corporateNumber: varchar("corporate_number").notNull(),
	name: varchar("name").notNull(),
	address: text("address"),
	isExpandedCoverage: boolean("is_expanded_coverage"),
	isActive: boolean("is_active").default(true),
	pensionOffice: varchar("pension_office"),
	coverageStartDate: date("coverage_start_date"),
	url: varchar("url"),
	favoriteCount: integer("favorite_count").default(0).notNull(),
	nameKana: varchar("name_kana"),
},
(table) => {
	return {
		pgroongaNameSearchIdx: index("pgroonga_name_search_index").using("pgroonga", table.name).with({normalizers: "NormalizerNFKC150(
    "unify_to_romaji", true,
    "unify_hyphen_and_prolonged_sound_mark", true
   )",tokenizer: "TokenNgram(
    "unify_alphabet", false,
    "unify_symbol", false,
    "unify_digit", false,
    "report_source_location", true
  )"}),
		companiesCorporateNumberUnique: unique("companies_corporate_number_unique").on(table.corporateNumber),
	}
});

export const jobListings = pgTable("job_listings", {
	id: uuid("id").defaultRandom().primaryKey().notNull(),
	jobNumber: text("job_number").notNull(),
	corporateNumber: text("corporate_number").notNull(),
	receptionDate: date("reception_date").notNull(),
	expirationDate: date("expiration_date").notNull(),
	publicEmploymentSecurityOffice: text("public_employment_security_office").notNull(),
	jobCategory: text("job_category").notNull(),
	onlineApplicationAccepted: boolean("online_application_accepted").notNull(),
	industryClassification: text("industry_classification").notNull(),
	trialEmploymentDesired: boolean("trial_employment_desired").notNull(),
	companyName: text("company_name").notNull(),
	companyNameKana: text("company_name_kana"),
	companyPostalCode: text("company_postal_code"),
	companyAddress: text("company_address").notNull(),
	companyWebsite: text("company_website"),
	employeeCountTotal: integer("employee_count_total"),
	employeeCountWorkplace: integer("employee_count_workplace"),
	femaleEmployeeCount: integer("female_employee_count"),
	partTimeEmployeeCount: integer("part_time_employee_count"),
	establishmentYear: integer("establishment_year"),
	capital: text("capital"),
	hasLaborUnion: boolean("has_labor_union"),
	businessDescription: text("business_description"),
	companyFeatures: text("company_features"),
	jobTitle: text("job_title").notNull(),
	jobDescription: text("job_description").notNull(),
	employmentType: text("employment_type").notNull(),
	isDispatch: boolean("is_dispatch").notNull(),
	dispatchLicenseNumber: text("dispatch_license_number"),
	employmentPeriod: text("employment_period"),
	workLocationPostalCode: text("work_location_postal_code"),
	workLocationAddress: text("work_location_address").notNull(),
	nearestStation: text("nearest_station"),
	commuteTime: integer("commute_time"),
	commuteMethod: text("commute_method"),
	smokingPolicy: text("smoking_policy"),
	carCommuteAllowed: boolean("car_commute_allowed"),
	baseSalaryMin: text("base_salary_min"),
	baseSalaryMax: text("base_salary_max"),
	fixedOvertimePay: text("fixed_overtime_pay"),
	fixedOvertimeHours: integer("fixed_overtime_hours"),
	salaryType: text("salary_type"),
	paymentDate: text("payment_date"),
	bonusSystem: boolean("bonus_system"),
	salaryRaiseSystem: boolean("salary_raise_system"),
	workHoursStart: time("work_hours_start"),
	workHoursEnd: time("work_hours_end"),
	breakTime: integer("break_time"),
	overtimeHoursAverage: integer("overtime_hours_average"),
	specialOvertimeConditions: text("special_overtime_conditions"),
	annualHolidays: integer("annual_holidays"),
	holidays: text("holidays"),
	paidLeaveDays: integer("paid_leave_days"),
	insuranceCoverage: text("insurance_coverage"),
	retirementSystem: boolean("retirement_system"),
	retirementAge: integer("retirement_age"),
	rehiringSystem: boolean("rehiring_system"),
	trialPeriod: boolean("trial_period"),
	trialPeriodDuration: text("trial_period_duration"),
	housingProvided: boolean("housing_provided"),
	childcareFacilityAvailable: boolean("childcare_facility_available"),
	ageLimitMin: integer("age_limit_min"),
	ageLimitMax: integer("age_limit_max"),
	ageLimitReason: text("age_limit_reason"),
	educationRequirement: text("education_requirement"),
	requiredExperience: text("required_experience"),
	requiredLicenses: text("required_licenses"),
	hiringCount: integer("hiring_count"),
	selectionMethods: text("selection_methods"),
	resultNotificationTiming: text("result_notification_timing"),
	resultNotificationMethod: text("result_notification_method"),
	requiredDocuments: text("required_documents"),
	applicationMethod: text("application_method"),
	selectionLocation: text("selection_location"),
	contactDepartment: text("contact_department"),
	contactPosition: text("contact_position"),
	contactPhoneNumber: text("contact_phone_number"),
	contactEmail: text("contact_email"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
},
(table) => {
	return {
		companyNameIdx: index().using("btree", table.companyName),
		corporateNumberIdx: index().using("btree", table.corporateNumber),
		expirationDateIdx: index().using("btree", table.expirationDate),
		jobNumberIdx: index().using("btree", table.jobNumber),
		jobTitleIdx: index().using("btree", table.jobTitle),
		receptionDateIdx: index().using("btree", table.receptionDate),
		jobListingsJobNumberUnique: unique("job_listings_job_number_unique").on(table.jobNumber),
	}
});

export const green = pgTable("green", {
	id: integer("id").primaryKey().notNull(),
	companyName: text("company_name").notNull(),
	industry: text("industry"),
	companyFeatures: text("company_features"),
	capital: text("capital"),
	sales: text("sales"),
	establishedDate: text("established_date"),
	ceo: text("ceo"),
	businessDescription: text("business_description"),
	stockListing: text("stock_listing"),
	majorShareholders: text("major_shareholders"),
	mainClients: text("main_clients"),
	employeeCount: integer("employee_count"),
	averageAge: numeric("average_age"),
	headquartersAddress: text("headquarters_address"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	companyId: uuid("company_id"),
});

export const findy = pgTable("findy", {
	id: integer("id").primaryKey().notNull(),
	companyName: text("company_name"),
	location: text("location"),
	description: text("description"),
	establishedAt: text("established_at"),
	president: text("president"),
	url: varchar("url", { length: 255 }),
	companyId: uuid("company_id"),
});